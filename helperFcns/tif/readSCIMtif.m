function [img,imHeader,frameRate,motorPos] = ...
    readSCIMtif(tifFileName,varargin)
% readSCIMtif  Load ScanImage .tif image data and header.
%   [img,imHeader,frameRate,motorPos] = readSCIMtif(tifFileName)
%   loads .tif. If multiple channels, img is a struct of size n channels with channel ID and
%   image data in each element.
%
%   Additional input arguments: 
%       'metaOnly' --> loads only image metadata, discards image data
%       '1' --> loads specified channel, replace with desired channel number
%               channel id stored in imHeader
%
%       TODO: handle merge
%       'merge' --> merges image data from 2 channels, assumes red,green
%
%   PAC_20200213
%
%   See also justLoadTif.m


imginfo = imfinfo(tifFileName);

if ~isfield(imginfo,'Software') && ~contains(imginfo(1).ImageDescription,'hScan2D')
    disp('tif was likely generated by SI v <5 (3.8)')
    header = strsplit(imginfo(1).ImageDescription,'\r');
    %initialize structure to contain header data
    %header fields are of object notation, evaluate them to automate
    %structure writing
    state = struct('configPath',[]);
    for k = 1:length(header)
        if ~isempty(header{k})
            evalc(header{k});
        end
    end
    imHeader = state;
    imHeader.nFrames = state.acq.numberOfFrames;
    imHeader.frameRate = imHeader.acq.frameRate;
    imHeader.motorPos.relative = [imHeader.motor.relXPosition...
        imHeader.motor.relYPosition...
        imHeader.motor.relZPosition];
    imHeader.motorPos.absolute = [imHeader.motor.absXPosition...
        imHeader.motor.absYPosition...
        imHeader.motor.absZPosition];
    
elseif isfield(imginfo,'Software')
    %for SI5.3 and up:
    disp('tif was likely generated by SI v5+')
    header = strsplit(imginfo(1).Software,'\n');
    for k = 1:length(header)
        if ~isempty(header{k})
            evalc(header{k});
        end
    end
    imHeader = SI;
    imHeader.nFrames = SI.hScan2D.logFramesPerFile;
    imHeader.frameRate = imHeader.hRoiManager.scanFrameRate;
try
    imHeader.motorPos.relative = imHeader.hMotors.motorPosition;
catch
    disp('couldn''t find relative motor position data')
    imHeader.motorPos.relative = [0 0 0];
end
try
    imHeader.motorPos.absolute = imHeader.hMotors.motorPositionTarget;
catch
    disp('couldn''t find absolute motor position data')
    imHeader.motorPos.absolute = [0 0 0];
end
    if isfield(imginfo,'Copyright')
        imHeader.tifFromSplit = imginfo(1).Copyright;
    end
else
    error('Don''t know how to handle the header for this tif')
end

imHeader.imWidth = imginfo(1).Width;
imHeader.imHeight = imginfo(1).Height;
frameRate = imHeader.frameRate;
motorPos = imHeader.motorPos;

%elect whether or not to load image data.
if nargin==1 || ~any(contains(string(varargin),'metaOnly','IgnoreCase',1))
    
    %prevents printing of irrelevant tif header errors
    warning('off','MATLAB:imagesci:tiffmexutils:libtiffWarning');
    warning('off','imageio:tiffmexutils:libtiffWarning');
    
    curtiff = Tiff(tifFileName,'r');

    if ~isfield(imginfo,'Software') && ~contains(imginfo(1).ImageDescription,'hScan2D')
        %This would be for ScanImage v3
        %THIS IS THE MEAT: read the actual tiff image
        for k = 1:imHeader.nFrames
            curtiff.setDirectory(k);
            img(:,:,k) = curtiff.read();
        end
        img = double(img);
        
    elseif isfield(imginfo,'Software')
        %for ScanImage v5.3+
        if numel(imHeader.hChannels.channelSave)==1 || isfield(imHeader,'tifFromSplit')
            for k = 1:imHeader.hScan2D.logFramesPerFile
                curtiff.setDirectory(k);
                img(:,:,k) = curtiff.read();
            end
            img = double(img);
        
        elseif any(cellfun(@(c) numel(c)==1 && isnumeric(c),varargin)) && ...
                numel(imHeader.hChannels.channelSave)>1
            nChan = numel(imHeader.hChannels.channelSave);
            imHeader.chanID = varargin{cellfun(@(c) numel(c)==1 && isnumeric(c),varargin)};
            disp(['Channel ' num2str(imHeader.chanID) ' selected'])
            fNo = 0;
            for k = imHeader.chanID:nChan:(imHeader.nFrames)*nChan
                curtiff.setDirectory(k);
                fNo = fNo+1;
                img(:,:,fNo) = curtiff.read();
            end
            img = double(img);
        
        elseif numel(imHeader.hChannels.channelSave)>1 || ...
                contains(varargin{cellfun(@ischar,varargin)},'merge')
            
            nChan = numel(imHeader.hChannels.channelSave);
            for iChan = 1:nChan
                img(iChan).chanID = imHeader.hChannels.channelSave(iChan);
                fNo = 0;
                for k = iChan:nChan:(imHeader.hScan2D.logFramesPerFile)*nChan
                    curtiff.setDirectory(k);
                    fNo = fNo+1;
                    img(iChan).img(:,:,fNo) = curtiff.read();
                end
                img(iChan).img = double(img(iChan).img);
            end
            
%             if contains(varargin{cellfun(@ischar,varargin)},'merge')
%                 error('Not yet coded')
%             end
            %for combining/merging split channels
            %imshow(cat(3,scaleZeroToOne(img(1).img(:,:,1)),scaleZeroToOne(img(2).img(:,:,1)),nan(256,256,1)))
            %or simply: imshow(redGreenMerge(img(1).img(:,:,1),img(2).img(:,:,1)))

        end            
    end
    curtiff.close();
    
    warning('on','MATLAB:imagesci:tiffmexutils:libtiffWarning')
    warning('on','imageio:tiffmexutils:libtiffWarning');
       
else
    img = [];
end

end